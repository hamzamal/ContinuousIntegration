//
// This Jenkinsfile builds the ontology-publisher image, runs a test and when the test passes it publishes the image
// to the Docker Registry
//
def app

pipeline {

  agent none

  environment {
    LC_ALL = 'en_US.UTF-8'
    LANG = 'en_US.UTF-8'
    LANGUAGE = 'en_US.UTF-8'
    ONTOLOGY_FAMILY = 'fibo'
    FIBO_BRANCH = 'master'
    ONTOLOGY_BUILDER_IMAGE = 'edmcouncil/ontology-publisher'
    REGISTRY = "https://registry.hub.docker.com"
  }

  options {

    buildDiscarder(
      logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '', daysToKeepStr: '', numToKeepStr: '5')
    )
    //
    // We let each stage running on each jenkins slave / agent decide what to check out or not
    //
    skipDefaultCheckout()
    //
    // Skip stages once the build status has gone to UNSTABLE.
    //
    skipStagesAfterUnstable()
    //
    // There must be SOME limit, if it hangs or whatever then that's a bug and therefore cancel the job.
    //
    timeout(time: 23, unit: 'HOURS')
    //
    // Prepend all console output generated by the Pipeline run with the time at which the line was emitted
    //
    //timestamps()
    ansiColor('xterm')
  }

  stages {

    stage('Prepare') {
      agent {
        label 'docker'
      }
      environment {
        PATH = "$PATH:/usr/bin"
      }
      steps {
        echo 'PATH=' + env.PATH
        echo 'ONTOLOGY_FAMILY=' + env.ONTOLOGY_FAMILY

        echo "Cleaning workspace:"
        sh 'rm -rf ${WORKSPACE}/* || true'
        echo "Done cleaning"

        //
        // Check out this repo in the publisher directory so that we're not copying the ontology-repo into
        // the image. We're building the image from the publisher directory.
        //
        dir('publisher') {
          checkout scm
          script {
            env.GIT_HASH_BUILDER = sh(
                    script: "#!/bin/sh -e\ngit show --oneline | head -1 | cut -d' ' -f1",
                    returnStdout: true
            ).trim()
          }

          echo "GIT_HASH_BUILDER=>${env.GIT_HASH_BUILDER}"
        }

        dir('fibo') {
          checkout changelog: false, poll: false, scm: [
            $class: 'GitSCM',
            branches: [
              [name: "*/${env.FIBO_BRANCH}"]
            ],
            doGenerateSubmoduleConfigurations: false,
            extensions: [
              [
                $class: 'CheckoutOption',
                timeout: 1
              ], [
                $class: 'CloneOption',
                noTags: true,
                reference: '',
                shallow: true,
                timeout: 1
              ], [
                $class: 'PruneStaleBranch'
              ], [
                $class: 'IgnoreNotifyCommit'
              ]
            ],
            submoduleCfg: [],
            userRemoteConfigs: [
              [
                credentialsId: '50cac519-d41c-4765-8563-c43b7f55c877',
                url: 'https://github.com/edmcouncil/fibo.git'
              ]
            ]
          ]
          script {
            env.GIT_HASH_ONTOLOGIES = sh(
                    script: "#!/bin/sh -e\ngit show --oneline | head -1 | cut -d' ' -f1",
                    returnStdout: true
            ).trim()
          }
          echo 'Checked out fibo repo'
          echo "GIT_HASH_ONTOLOGIES=>${env.GIT_HASH_ONTOLOGIES}"
        }
      }
    } // end of stage 'Prepare'

    stage('Build Image 1') {
      agent {
        label 'docker'
      }
      steps {
        sh "docker build --tag ${env.ONTOLOGY_BUILDER_IMAGE}:${env.GIT_HASH_BUILDER} ."
      }
    }

    stage('Build image') {
      agent {
        dockerfile {
          filename 'Dockerfile'
          dir 'publisher'
          additionalBuildArgs '--pull --tag ${ONTOLOGY_BUILDER_IMAGE}:${GIT_HASH_BUILDER} --build-arg ONTPUB_FAMILY=${ONTOLOGY_FAMILY}'
          args '-u 0:0 ' +
            '--mount type=bind,source=${WORKSPACE}/fibo,target=/input/fibo,readonly,consistency=cached ' +
            '-w /publisher'
        }
      }
      environment {
        PATH = "$PATH:/usr/bin"
      }
      //
      // Everything that happens below is done inside the container
      //
      steps {
        sh 'cd /publisher && ./publish.sh --help'
      }
    }

    stage('Test image') {
      agent {
        docker {
          image "${env.ONTOLOGY_BUILDER_IMAGE}:${env.GIT_HASH_BUILDER}"
        }
      }
      environment {
        PATH = "$PATH:/usr/bin"
      }
      //
      // Everything that happens below is done inside the container
      //
      steps {
        sh 'export | grep GIT_ ; cd /publisher && ./publish.sh index'
      }
    }

    stage('Publish Image') {
      agent {
        label 'docker'
      }
      when {
        branch 'master'
      }
      environment {
        PATH = "$PATH:/usr/bin"
      }
      steps {
        echo "Now publish the image ${env.ONTOLOGY_BUILDER_IMAGE}"
        withDockerRegistry([
          credentialsId: 'docker-hub-credentials',
          url: ''
        ]) {
          sh "export"
          sh "docker push --help"
          sh "echo 1 ${env.ONTOLOGY_BUILDER_IMAGE}"
          sh 'echo 2 ${env.ONTOLOGY_BUILDER_IMAGE}'
          sh "echo 3 ${ONTOLOGY_BUILDER_IMAGE}"
          sh 'echo 4 ${ONTOLOGY_BUILDER_IMAGE}'
          sh "echo 5 \${ONTOLOGY_BUILDER_IMAGE}"
          sh "docker push ${env.ONTOLOGY_BUILDER_IMAGE}:${env.GIT_HASH_BUILDER}"
          sh "docker push ${env.ONTOLOGY_BUILDER_IMAGE}:latest"
        }
      }
    }
  }
}